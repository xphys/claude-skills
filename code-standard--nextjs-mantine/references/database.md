# Database (Drizzle ORM + PostgreSQL)

## Library

This project uses **Drizzle ORM** (`drizzle-orm`) with **PostgreSQL** for database access. This project follows a **database-first** approach — the database schema is the source of truth. Drizzle Kit (`drizzle-kit`) introspects the database and generates TypeScript schema files.

---

## Project Structure

```
src/
├── db/
│   ├── index.ts              # Database client (drizzle instance)
│   ├── schema/               # Table definitions (one file per domain)
│   │   ├── index.ts          # Re-exports all tables and relations
│   │   ├── users.ts          # users table + relations
│   │   ├── posts.ts          # posts table + relations
│   │   └── orders.ts         # orders table + relations
│   └── migrations/           # SQL migration files (managed externally or via migration tool)
drizzle.config.ts              # Drizzle Kit configuration (project root)
```

### File Naming

| File | Convention | Example |
|------|-----------|---------|
| Schema files | camelCase, plural entity | `users.ts`, `orderItems.ts` |
| Schema barrel | `index.ts` | `db/schema/index.ts` |
| DB client | `index.ts` | `db/index.ts` |
| Config | `drizzle.config.ts` | Project root |

---

## Database Client Setup

```tsx
// db/index.ts
import { drizzle } from "drizzle-orm/node-postgres";
import { env } from "@/lib/env";
import * as schema from "./schema";

export const db = drizzle(env.DATABASE_URL, { schema });
```

Add `DATABASE_URL` to your Zod env validation (see [validation.md](./validation.md)):

```tsx
// lib/env.ts (extend existing schema)
const envSchema = z.object({
  // ... existing vars
  DATABASE_URL: z.string().url(),
});
```

---

## Drizzle Kit Configuration

```tsx
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  schema: "./src/db/schema/index.ts",
  out: "./src/db/migrations",
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
});
```

---

## Package Scripts

Add these scripts to `package.json` for database operations:

```json
{
  "scripts": {
    "db:pull": "drizzle-kit pull",
    "db:studio": "drizzle-kit studio",
    "db:check": "drizzle-kit check"
  }
}
```

| Script | Command | Purpose |
|--------|---------|---------|
| `pnpm db:pull` | `drizzle-kit pull` | Introspect database and generate/update TypeScript schema |
| `pnpm db:studio` | `drizzle-kit studio` | Launch visual database browser |
| `pnpm db:check` | `drizzle-kit check` | Verify TypeScript schema is in sync with database |

**Do not add** `db:push`, `db:generate`, or `db:migrate` scripts — this project uses database-first only.

---

## Schema Definition

### Database-First Workflow

Schema files are **generated by `drizzle-kit pull`**, not hand-written. The database is the source of truth.

```bash
# 1. Make schema changes in the database (SQL, migration tool, or DB GUI)
# 2. Pull the schema into TypeScript
pnpm drizzle-kit pull

# 3. Review generated files in db/schema/
# 4. Add relations (pull does not generate relations — add manually)
# 5. Commit the updated schema files
```

After pulling, **split the generated schema** into one file per domain entity and add relations manually.

### Table Pattern (after pull + manual cleanup)

```tsx
// db/schema/users.ts (generated by pull, then cleaned up)
import { pgTable, text, timestamp, uuid, varchar } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";
import { posts } from "./posts";

export const users = pgTable("users", {
  id: uuid("id").primaryKey().defaultRandom(),
  clerkId: text("clerk_id").notNull().unique(),
  email: varchar("email", { length: 255 }).notNull().unique(),
  displayName: varchar("display_name", { length: 100 }).notNull(),
  role: text("role", { enum: ["admin", "editor", "viewer"] }).notNull().default("viewer"),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});

// Relations are NOT generated by pull — add manually
export const usersRelations = relations(users, ({ many }) => ({
  posts: many(posts),
}));
```

```tsx
// db/schema/posts.ts (generated by pull, then cleaned up)
import { pgTable, text, timestamp, uuid, varchar } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";
import { users } from "./users";

export const posts = pgTable("posts", {
  id: uuid("id").primaryKey().defaultRandom(),
  title: varchar("title", { length: 255 }).notNull(),
  content: text("content"),
  authorId: uuid("author_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});

// Relations are NOT generated by pull — add manually
export const postsRelations = relations(posts, ({ one }) => ({
  author: one(users, {
    fields: [posts.authorId],
    references: [users.id],
  }),
}));
```

### Schema Barrel

Re-export everything from one file:

```tsx
// db/schema/index.ts
export * from "./users";
export * from "./posts";
export * from "./orders";
```

---

## Type Inference

Use Drizzle's built-in type inference — **not manual interfaces** for database entities:

```tsx
// db/schema/users.ts (add at bottom of schema file)

// Infer types from schema — single source of truth
export type TUser = typeof users.$inferSelect;          // Full row (SELECT *)
export type TNewUser = typeof users.$inferInsert;        // Insert payload
```

### When to Use Drizzle Types vs Zod Types

| Context | Use |
|---------|-----|
| Database layer (queries, services) | **Drizzle inferred types** (`TUser`, `TNewUser`) |
| API/form input validation | **Zod schema** with `z.infer<>` (`TCreateUserInput`) |
| Client components | **Zod types** or a subset/mapped type |

**Don't duplicate** — Drizzle types represent the database shape; Zod schemas represent the input shape. They are different and both valid.

```tsx
// db/schema/users.ts
export type TUser = typeof users.$inferSelect;           // { id, clerkId, email, displayName, role, createdAt, updatedAt }

// lib/validations/user.ts
export type TCreateUserInput = z.infer<typeof createUserSchema>;  // { email, displayName, role }
```

---

## Query Patterns

### In Server Actions

Server Actions call the database directly through `db`. No API layer in between.

```tsx
// actions/userActions.ts
"use server";

import { db } from "@/db";
import { users } from "@/db/schema";
import { eq } from "drizzle-orm";

export async function getUsers(): Promise<TUser[]> {
  return db.select().from(users).orderBy(users.createdAt);
}

export async function getUserById(id: string): Promise<TUser | undefined> {
  const [user] = await db.select().from(users).where(eq(users.id, id));
  return user;
}
```

### Select with Relations

```tsx
// Fetch user with their posts (uses relational query API)
const usersWithPosts = await db.query.users.findMany({
  with: {
    posts: true,
  },
});

// Fetch single user with posts
const user = await db.query.users.findFirst({
  where: eq(users.id, id),
  with: {
    posts: {
      orderBy: (posts, { desc }) => [desc(posts.createdAt)],
      limit: 10,
    },
  },
});
```

### Insert

```tsx
export async function createUser(data: TCreateUserInput): Promise<IActionResult<{ id: string }>> {
  const parsed = createUserSchema.safeParse(data);
  if (!parsed.success) {
    return { success: false, error: parsed.error.issues[0].message };
  }

  try {
    const [user] = await db.insert(users).values(parsed.data).returning({ id: users.id });
    revalidatePath("/users");
    return { success: true, data: { id: user.id } };
  } catch {
    return { success: false, error: "Failed to create user" };
  }
}
```

### Update

```tsx
export async function updateUser(id: string, data: TUpdateUserInput): Promise<IActionResult> {
  const parsed = updateUserSchema.safeParse(data);
  if (!parsed.success) {
    return { success: false, error: parsed.error.issues[0].message };
  }

  try {
    await db.update(users).set(parsed.data).where(eq(users.id, id));
    revalidatePath("/users");
    revalidatePath(`/users/${id}`);
    return { success: true };
  } catch {
    return { success: false, error: "Failed to update user" };
  }
}
```

### Delete

```tsx
export async function deleteUser(id: string): Promise<IActionResult> {
  try {
    await db.delete(users).where(eq(users.id, id));
    revalidatePath("/users");
    return { success: true };
  } catch {
    return { success: false, error: "Failed to delete user" };
  }
}
```

### Filtering & Pagination

```tsx
import { eq, and, ilike, desc, sql } from "drizzle-orm";

export async function getUsers(filters: TUserFilters) {
  const conditions = [];

  if (filters.role) {
    conditions.push(eq(users.role, filters.role));
  }
  if (filters.search) {
    conditions.push(ilike(users.displayName, `%${filters.search}%`));
  }

  const where = conditions.length > 0 ? and(...conditions) : undefined;

  const [data, [{ count }]] = await Promise.all([
    db
      .select()
      .from(users)
      .where(where)
      .orderBy(desc(users.createdAt))
      .limit(filters.pageSize)
      .offset((filters.page - 1) * filters.pageSize),
    db
      .select({ count: sql<number>`count(*)` })
      .from(users)
      .where(where),
  ]);

  return { data, total: count };
}
```

### Transactions

Use transactions for operations that must succeed or fail together:

```tsx
export async function transferOrder(orderId: string, newOwnerId: string): Promise<IActionResult> {
  try {
    await db.transaction(async (tx) => {
      const [order] = await tx.select().from(orders).where(eq(orders.id, orderId));

      if (!order) {
        tx.rollback();
        return;
      }

      await tx.update(orders).set({ ownerId: newOwnerId }).where(eq(orders.id, orderId));
      await tx.insert(auditLog).values({
        action: "transfer",
        entityId: orderId,
        fromUserId: order.ownerId,
        toUserId: newOwnerId,
      });
    });

    revalidatePath("/orders");
    return { success: true };
  } catch {
    return { success: false, error: "Transfer failed" };
  }
}
```

---

## Migration Workflow (Database-First)

This project uses a **database-first** approach. The database schema is the source of truth — not TypeScript files.

### How Schema Changes Work

```bash
# 1. Make changes in the database
#    - Write SQL migrations manually, use a migration tool, or modify via DB GUI
#    - Apply the migration to your database

# 2. Pull the updated schema into TypeScript
pnpm drizzle-kit pull

# 3. Review the generated/updated schema files in db/schema/
#    - Split into per-domain files if pull generated a single file
#    - Add/update relations (pull does not generate them)

# 4. Commit the updated schema files
```

### Inspect Database

```bash
# Launch Drizzle Studio (visual database browser)
pnpm drizzle-kit studio
```

### Rules

- **Database is the source of truth** — never define schema in TypeScript first. Always start with SQL.
- **Use `drizzle-kit pull`** to sync TypeScript schema from the database. Do not use `push`, `generate`, or `migrate`.
- **Relations are manual** — `pull` generates table definitions but not Drizzle relations. Add `relations()` calls by hand after pulling.
- **Split pulled schema** — if `pull` generates a single file, split it into one file per domain entity.
- **Commit schema files** — they are the TypeScript representation of the database and must stay in sync.
- **Review after pull** — always review generated schema for correctness before committing.

---

## Schema Conventions

### Column Naming

- Use **snake_case** for SQL column names: `created_at`, `display_name`, `clerk_id`
- Use **camelCase** for TypeScript property names: `createdAt`, `displayName`, `clerkId`
- Drizzle maps between them: `timestamp("created_at")` → access as `user.createdAt`

### Common Patterns

```tsx
// UUID primary key (prefer over serial for distributed systems)
id: uuid("id").primaryKey().defaultRandom(),

// Timestamps (always include both)
createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow().$onUpdate(() => new Date()),

// Foreign key with cascade delete
authorId: uuid("author_id").notNull().references(() => users.id, { onDelete: "cascade" }),

// Enum column
role: text("role", { enum: ["admin", "editor", "viewer"] }).notNull().default("viewer"),

// Soft delete
deletedAt: timestamp("deleted_at", { withTimezone: true }),
```

### Table Naming

- Tables are **plural snake_case**: `users`, `order_items`, `audit_logs`
- TypeScript table variables are **camelCase plural**: `users`, `orderItems`, `auditLogs`

---

## Services Layer

For complex business logic, put query logic in `services/` and keep Server Actions thin:

```tsx
// services/userService.ts
import { db } from "@/db";
import { users } from "@/db/schema";
import { eq } from "drizzle-orm";
import type { TUser, TNewUser } from "@/db/schema/users";

export async function findUserByClerkId(clerkId: string): Promise<TUser | undefined> {
  const [user] = await db.select().from(users).where(eq(users.clerkId, clerkId));
  return user;
}

export async function createUserFromClerk(data: TNewUser): Promise<TUser> {
  const [user] = await db.insert(users).values(data).returning();
  return user;
}
```

```tsx
// actions/userActions.ts
"use server";

import { findUserByClerkId } from "@/services/userService";

export async function getProfile(): Promise<TUser | undefined> {
  const { userId } = await auth();
  if (!userId) return undefined;
  return findUserByClerkId(userId);
}
```

### When to Use services/ vs Direct Queries in Actions

| Complexity | Where to put queries |
|-----------|---------------------|
| Simple CRUD (1 query) | Directly in the Server Action |
| Reused across multiple actions | `services/` |
| Complex business logic / multi-step | `services/` |
| Transaction with multiple tables | `services/` |

---

## Rules

- **Database is the source of truth** — schema changes happen in SQL first, then `drizzle-kit pull` syncs TypeScript. Never define schema in TypeScript first.
- **Types from Drizzle inference** — use `$inferSelect` / `$inferInsert`, not manual interfaces.
- **One schema file per domain** — `users.ts`, `posts.ts`, `orders.ts`. Not one giant `schema.ts`. Split after `pull` if needed.
- **Relations are manual** — `pull` does not generate `relations()` calls. Add them by hand after pulling.
- **Always use parameterized queries** — Drizzle handles this by default. Never concatenate user input into `sql\`\`` template literals.
- **Use `returning()`** for inserts/updates when you need the result — avoids a separate SELECT.
- **Use relational queries** (`db.query.*.findMany`) for nested data — avoids manual joins for common patterns.
- **Use SQL-style queries** (`db.select().from()`) for complex filters, aggregations, and joins.
- **Transactions for multi-table mutations** — never leave related writes without atomicity guarantees.
- **No `push`, `generate`, or `migrate`** — this project uses database-first. Use `drizzle-kit pull` only.
- **Server-only** — never import from `@/db` in client components. Database access happens in Server Components, Server Actions, and API routes only.
